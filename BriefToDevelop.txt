Исходные данные
Для проекта платформы по перепродаже вещей создана фронтенд-часть сайта.
Чтобы запустить фронтенд с помощью установленного Docker, нужно открыть командную строку (или терминал) и выполнить
следующую команду: docker run -p 3000:3000 --rm ghcr.io/bizinmitya/front-react-avito:v1.19
После выполнения команды фронтенд запустится на порту 3000 и можно будет зайти на него через браузер по адресу:
http://localhost:3000

Что необходимо сделать
Нужно написать бэкенд-часть сайта на Java. Бэкенд-часть проекта предполагает реализацию следующего функционала:

Авторизация и аутентификация пользователей.
Распределение ролей между пользователями: пользователь и администратор.
CRUD-операции для объявлений и комментариев: администратор может удалять или редактировать все объявления и комментарии,
а пользователи — только свои.
Возможность для пользователей оставлять комментарии под каждым объявлением.
Показ и сохранение картинок объявлений, а также аватарок пользователей.

Nice to have
Код должен быть корректно отформатирован.
Код проекта не должен содержать дублирований более чем в 3 строки, общие операции необходимо выносить в сервисы или
утилитарные методы.
Переменные и классы должны быть названы корректно, название должно отражать суть класса или переменной.
Код не должен содержать закомментированных участков, недостижимых инструкций и неиспользуемых методов.
Код должен следовать принципу SRP: каждый класс должен выполнять одну задачу или работать с одной сущностью.
Код должен быть покрыт тестами, в данном случае приоритет у интеграционных тестов, но некоторые компоненты — например,
мапперы — можно тестировать с помощью unit-тестов.

Этапы проекта (1 этап = 1 неделя)
Этап I. Написание DTO, контроллеров.
Этап II. Написание сущностей, репозиториев, мапперов.
Этап III. Написание сервисов.

Ресурсы:
Исходник: https://github.com/skypro-backend/example-for-graduate-work
Openapi.yaml-файл: https://github.com/BizinMitya/front-react-avito/blob/v1.19/openapi.yaml
Swagger: https://editor.swagger.io/.


Задание Этап I: написание DTO, контроллеров

Вам предстоит подготовить Spring-проект к работе. Для этого распределите задачи между участниками команды и выполните
следующие шаги:
* Запустите фронтенд в Docker по рекомендациям из ТЗ.
* Сделайте форк шаблона проекта в GitHub к одному из участников команды.
* Добавьте в остальных участников команды в этот проект как сотрудников(Collaborators).
* Скачайте openapi.yaml-файл по ссылке и скопируйте его содержимое в https://editor.swagger.io/. Опишите скелет приложения на основе openapi.yaml-файла. Это значит, что нужно добавить необходимые контроллеры и DTO-классы, которые будут возвращать значения по умолчанию (пустые объекты DTO).
* Проверьте, что код работает и возвращает значения по умолчанию с помощью Postman.



Задания Этапа II: написание сущностей, репозиториев, мапперов.

На этой неделе работы над проектом вам необходимо:
* Подключить БД PostgreSQL.
* Создать необходимые сущности: пользователь, объявление, комментарий. Решение о том, какие поля добавлять в эти
  сущности, надо принять на основе DTO, которые вы написали на предыдущем этапе.
* Написать репозитории для работы с созданными сущностями.
* Написать сервисы, которые маппят (устанавливают соответствие) из сущностей в DTO и обратно.

Первое, с чего необходимо начать, — подключить базу данных к нашему проекту. Далее нужно проанализировать данные,
которыми обмениваются клиентская и серверная стороны, и на основе этого анализа составить модель данных - сущности и
таблицы. На данном этапе реализации проекта нужно добавить все DTO и Entity в проект. DTO - это не то же самое, что
сущности. Сущности (а по сути таблицы БД) не должны содержать избыточных данных (колонок), также должны быть правильно
расставлены связи между ними.

Далее необходимо написать мапперы для сущностей. Маппинг — процесс сопоставления полей объекта одного класса с полями
объекта другого класса. То есть это установление соотношения между моделями данных, которые находятся в разных
источниках или системах. В нашем случае это процесс конвертации DTO-класса в Entity и обратно.

Код, который маппит, можете написать сами, а можете использовать библиотеку https://mapstruct.org/, но в этом случае
вам самим нужно будет разобраться, как ей пользоваться.

Также на этом этапе должны быть созданы все необходимые репозитории для работы с сущностями.

Критерии проверки
* Созданы сущности, отражающие функциональность приложения.
* Сущности содержат ограничения, согласующиеся со спецификацией OpenAPI.
* Сущности используют корректные типы данных, согласующиеся со спецификацией OpenAPI
* Сущности содержат корректные связи, отсутствует избыточность данных
* Для каждой сущности написан мапер который трансформирует сущность в DTO.



Задания Этапа III. Написание сервисов.

На прошлом этапе вы написали логику маппинга, на этой неделе вам предстоит:
Связать данные, которые приходят в контроллеры в виде DTO, с БД. Другими словами, вам нужно написать сервисы, которые
будут работать с БД при помощи репозиториев, а также использовать мапперы для преобразования объектов из DTO в сущности
и обратно.

Рекомендации для выполнения задания Этапа III.
Вы можете обратить внимание на то, что в спецификации используется обозначение pk. pk в полях объектов означает
primary key, или первичный ключ. Если обратиться к Spring Data, то над полем, которое является первичным ключом,
ставится аннотация @Id.

Также в выданном API в некоторых запросах вы можете заметить, что не хватает данных на вход.
Например, имени пользователя. В этом случае данные нужно брать из авторизации, которую вы добавите следующим шагом.
А пока что (временно, в данной работе) вы можете захардкодить пользователя (стандартного из WebSecurityConfig).

Также в некоторых запросах есть работа с картинками, это тоже нужно пока что игнорировать: картинки не сохранять и
не обновлять, в DTO отправлять в полях image значение null.

Критерии проверки:
* Установлена связь между контроллерами, сервисами и репозиториями.
* Приложение работает в соответствии с OpenAPI-спецификацией.
* Большинство действий, не требующих аутентификации на фронтенде, работают правильно и выдают результат.



Задания Этапа IV: настройка авторизации и аутентификации, определение permissions к методам.

Теперь пришло время настроить аутентификацию и авторизацию пользователя в БД:
* заменить InMemoryUserDetailsManager на JdbcUserDetailsManager или на вашу собственную реализацию интерфейса
UserDetailsManager.
* Настроить SecurityFilterChain таким образом, чтобы выполнялись требования к модели безопасности.
* Добавить дополнительные проверки ролей в тех методах, где невозможно проверить авторизацию с помощью
SecurityFilterChain: например, редактирование чужого комментария или объявления.

Требования к модели безопасности приложения:

1) Пользователи хранятся в БД, аутентификация пользователей происходит с использованием БД.

2) Неавторизованный пользователь может:
 - получать список объявлений.

3) Авторизованный пользователь с ролью USER может:
 * получать список объявлений,
 * получать объявление по id,
 * создавать объявление,
 * редактировать и удалять свое объявление,
 * получать список комментариев,
 * создавать комментарии,
 * редактировать/удалять свои комментарии.

4) Авторизованный пользователь с ролью ADMIN может:
 * редактировать или удалять объявления и комментарии любых других пользователей.

5) Реализована возможность смены пароля пользователя.

Критерии проверки:
 * Фронт-часть приложения выполняет все перечисленные в "Требования к модели безопасности приложения" функции.
 * Запросы с Postman с неправильным паролем или логином должны отваливаться с кодом 401. Запросы с нарушением
   permissions (например, пользователь с ролью USER пытается удалить не свое объявление) возвращают код 403.



   Задания Этапа 5: сохранение и получение картинок.
  1) Обработайте получение картинок в контроллерах и также реализуйте возможность получать эти картинки из вашего
     приложения. Итогом данной задачи будет возможность фронта сохранить картинку, а потом отобразить ее в объявлениях,
     а также на аватарках пользователей, в комментариях и в профиле.

  2) С помощью Loom или другой удобной вам программы сделайте скринкаст, который содержит:
     * Обзор кода вашего приложения — рассказ о том, каким образом работают основные функции и как строилась модель
       данных приложения.
     * Используемые технологии — что вы используете для миграций, как писали тесты и так далее
     * Обзор тестовых сценариев, если они есть.
     * Демонстрацию работы вашего приложения и проход по основным вариантам использования — залогиниться, создать 4
       объявление и так далее.
     * Используйте это демо как возможность потренировать рассказ о своих проектах на собеседованиях.

Критерии проверки:
 * Написаны методы для получения и обновления картинок пользователя.
 * Написаны методы для получения и обновления картинок объявлений.
 * Видео, присланное на платформу, содержит все перечисленные в задании элементы.


 Задания Этапа VI
 На данном этапе у вас нет дополнительного технического задания, но вам нужно поправить ваш проект по предыдущим
 комментариям и замечаниям от наставника.

 На защите диплома у вас должно быть:
 * Работающее приложение, которое можно показать.
 * Полностью описанная документация проекта: README со списком используемых технологий, общим описанием проекта и
   участниками команды, а также Javadoc-комментарии для сервисов и для публичных методов.
 * Код проекта на GitHub.
 * Продуманный устный рассказ о проекте.